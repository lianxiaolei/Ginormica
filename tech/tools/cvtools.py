# -*- coding: utf-8 -*-

import cv2
import os
import random
import skimage
import numpy as np


def generate():
    """
    生成固定格式的算式
    :return:
    """
    ds = '0123456789'
    ts = ['{}{}{}{}{}', '({}{}{}){}{}', '{}{}({}{}{})']
    os = '+-*/'
    # os = ['+', '-', 'times', 'div']
    cs = [random.choice(ds) if x % 2 == 0 else random.choice(os) for x in range(5)]
    return random.choice(ts).format(*cs)


def get_img_by_char(char, base_path='./pre_ocr'):
    """
    get a img by giving char
    :param char:
    :param base_path:
    :return:
    """
    opdict = {'+': 10, '-': 11, '*': 12, '/': 13, '=': 14, '(': 15, ')': 16}
    if char in opdict.keys():
        char = opdict[char]
    path = os.path.join(base_path, str(char))
    files = os.listdir(path)

    rdm = random.randint(0, len(files) - 1)

    if rdm >= len(files):
        print(path, len(files), rdm)

    file = files[rdm]
    path = os.path.join(path, file)
    return cv2.imread(path, cv2.IMREAD_GRAYSCALE)


def get_sequence_img(chars):
    """
    generate sequence img generated by a char sequence
    :param chars:
    :return:
    """
    x = get_img_by_char(chars[0])
    for i in range(1, len(chars)):
        x = np.hstack([x, get_img_by_char(chars[i])])
    x = cv2.resize(x, (400, 80))
    x = skimage.util.random_noise(x, mode='gaussian', clip=True)  # add gaussian noise
    return x


def generate_chars(rnn_length, batch_size=128):
    """
    generate crnn input data
    :param rnn_length:
    :param batch_size:
    :return:
    """
    characters = '0123456789+-*/=()'
    width, height, n_len, n_class = 400, 80, 10, len(characters) + 1
    X = np.zeros((batch_size, width, height, 1), dtype=np.uint8)
    y = np.zeros((batch_size, n_len), dtype=np.uint8)
    while True:
        for i in range(batch_size):
            random_str = ''.join([random.choice(characters) for j in range(n_len)])
            tmp = np.array(get_sequence_img(random_str))
            tmp = tmp.reshape(tmp.shape[0], tmp.shape[1], 1)
            X[i] = tmp.transpose(1, 0, 2)
            y[i] = [characters.find(x) for x in random_str]
        yield [X, y, np.ones(batch_size) * rnn_length, np.ones(batch_size) * n_len], np.ones(batch_size)


def get_img_with_fname(fname, size=None):
    """

    :param fname:
    :param size:
    :return:
    """
    img = cv2.imread(fname)
    if size:
        img = cv2.resize(img, size)
    return img
